use std::io; // импортируем модуль для ввода-вывода

// функция для определения победителя игры
fn find_winner(n: usize, m: usize, nums: &Vec<i32>) -> i32 {
    // создаем вектор dp, где dp[i] будет хранить максимальную разницу очков
    // между текущим игроком и противником для i оставшихся чисел
    let mut dp = vec![-1_000_000_000; n + 1]; // заполняем очень маленькими числами, так как будем искать максимум

    // создаем вектор для хранения префиксных сумм
    let mut prefix = vec![0; n + 1]; // сумма первых i элементов

    // вычисляем префиксные суммы для быстрого нахождения суммы любых k элементов
    for i in 1..=n {
        prefix[i] = prefix[i - 1] + nums[i - 1];
    }

    // базовый случай: если чисел не осталось (i=0), разница очков 0
    dp[0] = 0;

    // заполняем массив dp для всех возможных количеств оставшихся чисел
    for i in 1..=n {
        // перебираем все возможные количества чисел k, которые можно взять на этом ходу (от 1 до m)
        for k in 1..=m.min(i) {
            // сумма взятых k чисел (первые k из оставшихся i чисел)
            let sum = prefix[i] - prefix[i - k];
            // разница очков, если мы возьмем k чисел:
            // sum (наши очки) минус лучший результат противника для оставшихся i-k чисел
            let diff = sum - dp[i - k];
            // если эта разница лучше текущей, обновляем dp[i]
            if diff > dp[i] {
                dp[i] = diff;
            }
        }
    }

    // если разница отрицательна, значит выигрывает второй игрок (вика), иначе первый (павел)
    if dp[n] < 0 {
        1 // павел выиграл
    } else {
        0 // вика выиграла
    }
}

fn main() {
    // создаем буфер для чтения строки
    let mut input = String::new();

    // выводим сообщение для ввода n и m
    println!("введите количество чисел в последовательности (n) и максимальное количество чисел для удаления за ход (m):");
    // читаем строку с вводом
    io::stdin().read_line(&mut input).expect("не удалось прочитать строку");
    // разбиваем строку по пробелам и парсим в числа
    let parts: Vec<&str> = input.trim().split_whitespace().collect();

    // парсим n
    let n: usize = parts[0].parse().expect("не удалось распарсить n");
    // парсим m
    let m: usize = parts[1].parse().expect("не удалось распарсить m");

    // проверка на корректность ввода
    if n < 1 || n > 50000 || m < 1 || m > 100 {
        println!("некорректные входные данные. убедитесь, что 1 <= n <= 50000 и 1 <= m <= 100.");
        return;
    }

    // создаем вектор для хранения последовательности чисел
    let mut nums = Vec::with_capacity(n);
    println!("введите последовательность из {} целых чисел:", n);
    // читаем следующую строку с числами
    input.clear();
    io::stdin().read_line(&mut input).expect("не удалось прочитать строку");
    // разбиваем строку по пробелам и парсим числа
    let nums_str: Vec<&str> = input.trim().split_whitespace().collect();

    // проверка, что введено ровно n чисел
    if nums_str.len() != n {
        println!("введено неверное количество чисел");
        return;
    }

    // парсим каждое число и добавляем в вектор
    for s in nums_str {
        let num: i32 = s.parse().expect("не удалось распарсить число");
        nums.push(num);
    }

    // вызываем функцию для определения победителя
    let winner = find_winner(n, m, &nums);

    // выводим результат
    println!("результат: {}", winner);
    println!("(1 - павел выиграл, 0 - вика выиграла)");
}
